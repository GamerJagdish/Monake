# Secure Leaderboard Implementation

This document explains the security measures implemented to prevent cheating in the Snake game leaderboard.

## Security Problem

The original contract allowed anyone to call `submitScore()` directly, which meant players could:
- Submit fake scores without playing the game
- Use bots to submit scores
- Manipulate scores by calling the contract directly

## Security Solution

### 1. Cryptographic Signatures

The new contract requires cryptographically signed scores that can only be generated by your game server:

- **Game Server Private Key**: Only your server knows this key
- **Score Signing**: Server signs each valid score with player address, score, and timestamp
- **Contract Verification**: Contract verifies the signature came from the authorized game server

### 2. Signature Replay Protection

- **Used Signatures Tracking**: Each signature can only be used once
- **Timestamp Validation**: Signatures expire after 5 minutes to prevent old score reuse

### 3. Game Data Validation

The API endpoint validates game data before signing scores:
- **Game Duration**: Must be reasonable (10 seconds to 10 minutes)
- **Move Validation**: Number of moves must correlate with the score
- **Score Consistency**: Final score must match reported score

## Implementation Flow

```
1. Player plays Snake game on your website
2. Game collects move data and validates gameplay
3. Game sends score + game data to your API endpoint
4. API validates the game data for cheating patterns
5. API signs the score with the game server private key
6. Player submits signed score to the smart contract
7. Contract verifies signature and records score
```

## Files Changed

### Smart Contract
- `contracts/Leaderboard.sol` - Updated with signature verification
- `lib/leaderboard-abi.ts` - New ABI with secure functions

### Backend API
- `app/api/sign-score/route.ts` - Signs valid scores
- `lib/secure-score.ts` - Utility functions for score signing

### Environment Variables
- `GAME_SERVER_PRIVATE_KEY` - Private key for signing scores (keep secret!)

## Deployment

1. Generate a new private key for the game server:
```bash
# Generate a new private key (save this securely!)
node -e "console.log('0x' + require('crypto').randomBytes(32).toString('hex'))"
```

2. Add the private key to your environment variables:
```bash
# .env.local
GAME_SERVER_PRIVATE_KEY="0x1234567890abcdef..."
```

3. Deploy the secure contract:
```bash
npx hardhat run scripts/deploy-secure-leaderboard.ts --network monad-testnet
```

4. Update your frontend with the new contract address

## Security Best Practices

### Server-Side
- **Keep Private Key Secret**: Never expose the game server private key
- **Validate Game Data**: Implement sophisticated game validation logic
- **Rate Limiting**: Add rate limits to prevent spam
- **Logging**: Log all score submissions for monitoring

### Client-Side
- **Collect Game Data**: Track all player moves and timing
- **Validate Locally**: Basic validation before sending to server
- **Handle Errors**: Graceful handling of signature failures

## Additional Security Measures

### Game Data Validation Ideas
- **Move Sequence Validation**: Ensure moves follow game rules
- **Timing Analysis**: Detect bot-like consistent timing
- **Score Progression**: Validate realistic score increases
- **Session Tracking**: Prevent multiple simultaneous games

### Monitoring
- **Suspicious Patterns**: Monitor for unusual score patterns
- **Failed Validations**: Track and investigate failed validations
- **High Scores**: Manual review of exceptionally high scores

## Testing

Test the security by trying to:
1. Submit scores without playing the game
2. Replay old signatures
3. Submit scores with invalid game data
4. Call the contract directly without signatures

All of these should fail with the new implementation.

## Limitations

- **Client-Side Game**: Game logic still runs on client, so determined cheaters might find ways to manipulate it
- **Server Dependency**: Requires your server to be online for score submission
- **Gas Costs**: Signature verification adds small gas cost to transactions

## Future Improvements

- **Zero-Knowledge Proofs**: For even stronger security without revealing game data
- **Commit-Reveal Schemes**: Hide scores until game completion
- **Multi-Signature Validation**: Require multiple validators for high scores
- **On-Chain Game Logic**: Move critical game logic to smart contract